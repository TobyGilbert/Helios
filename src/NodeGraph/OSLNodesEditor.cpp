#include "NodeGraph/OSLNodesEditor.h"
#include <iostream>
#include <QFile>
#include <QDir>
#include <QFileInfo>
#include <QTextStream>
#include <QDate>
#include <QGraphicsScene>
#include <algorithm>
#include "NodeGraph/qneconnection.h"


//------------------------------------------------------------------------------------------------------------------------------------
OSLNodesEditor::OSLNodesEditor(QObject *parent) :
    QNodesEditor(parent)
{
    //set our material destination
    m_optixMatDest = "OptixMaterials/tempMat.cu";

}
//------------------------------------------------------------------------------------------------------------------------------------
QString OSLNodesEditor::portTypeToString(QNEPort::variableType _type){
    switch(_type){
        case(QNEPort::TypeFloat): return QString("float"); break;
        case(QNEPort::TypeInt): return QString("int"); break;
        case(QNEPort::TypeNormal): return QString("float3"); break;
        case(QNEPort::TypeColour): return QString("float3"); break;
        case(QNEPort::TypePoint): return QString("float3"); break;
        case(QNEPort::TypeMatrix): return QString("float*"); break;
        default: std::cerr<<"Unknown Port Type in shader Compilation"<<std::endl; break;
    }
    return "";
}
//------------------------------------------------------------------------------------------------------------------------------------
QNEBlock *OSLNodesEditor::getLastBlock(){
    //iterate through our graphics items in our scene
    foreach(QGraphicsItem *item, getScene()->items())
    {
        //if its a shader block then lets see if its got Ci in it
        if (item->type() == OSLShaderBlock::Type)
        {
            //iterate through all our ports of the block
            QVector<QNEPort*> blockPorts = ((OSLShaderBlock*)item)->ports();
            foreach(QNEPort* port,blockPorts){
                //if the port is an output and its name is Ci then we have a last block
                if(port->isOutput() && (port->getName() == "Ci")){
                    return (QNEBlock*)item;
                }
            }
        }
    }
    //if we get to here then we have not found the last block
    return 0;

}
//------------------------------------------------------------------------------------------------------------------------------------
void OSLNodesEditor::evaluateBlock(QNEBlock *_block, std::vector<QNEBlock *> &_blockVector){
    //check if our block has already been evaluated
    std::vector<QNEBlock*>::iterator it = std::find(_blockVector.begin(),_blockVector.end(),_block);
    if(it != _blockVector.end()){
        return;
    }
    else{
        //if its not been evaluated check all of its imputs to see if they have been evaluated
        QVector<QNEPort*> blockPorts = ((OSLShaderBlock*)_block)->ports();
        foreach(QNEPort* port,blockPorts){
            //if the port is an input check to see if its connected to another shader
            if(!port->isOutput()){
                //get all the connections of our port
                QVector<QNEConnection*> connections = port->connections();
                foreach(QNEConnection* con, connections){
                    //check which port of the connection is the output of the previous node
                    if(con->port1()->isOutput()){
                        evaluateBlock(con->port1()->block(),_blockVector);
                    }
                    else{
                        evaluateBlock(con->port2()->block(),_blockVector);
                    }
                }
            }
        }
        _blockVector.push_back(_block);
        return;
    }
}

//------------------------------------------------------------------------------------------------------------------------------------
void OSLNodesEditor::createOptixMaterial()
{
    QFileInfo fileInfo(m_optixMatDest.c_str());
    if(!QDir(fileInfo.absoluteDir()).exists()){
        QDir().mkdir(fileInfo.absolutePath());
    }
    QFile myfile(m_optixMatDest.c_str());

    if(myfile.open(QIODevice::WriteOnly)){

        QTextStream stream(&myfile);
        QDate date;
        stream<<"//This file has been automatically generated by Declan Russell's xX_OSL Node Editor Hyper_Xx #NoScopez on the "<<date.currentDate().toString("dd.MM.yyyy")<<endl;

        //add our includes and namespaces
        stream<<"#include <optix.h>"<<endl;
        stream<<"#include <optixu/optixu_math_namespace.h>"<<endl;
        stream<<"#include \"helpers.h\""<<endl;
        stream<<"using namespace optix;"<<endl;
        stream<<"\n\n";
        //declare our structures
        /// @todo Might be worth having these in a header file as they are common structs to have
        stream<<"struct ShaderGlobals{"<<endl;
        stream<<"   float3 P;"<<endl;
        stream<<"   float3 I;"<<endl;
        stream<<"   float3 N;"<<endl;
        stream<<"   float3 Ng;"<<endl;
        stream<<"   float u, v;"<<endl;
        stream<<"};"<<endl;
        stream<<endl;
        stream<<"struct PerRayData_pathtrace{"<<endl;
        stream<<"   float3 result;"<<endl;
        stream<<"   float3 radiance;"<<endl;
        stream<<"   float3 attenuation;"<<endl;
        stream<<"   float3 origin;"<<endl;
        stream<<"   float3 direction;"<<endl;
        stream<<"   float importance;"<<endl;
        stream<<"   unsigned int seed;"<<endl;
        stream<<"   int depth;"<<endl;
        stream<<"   int countEmitted;"<<endl;
        stream<<"   int done;"<<endl;
        stream<<"   int inside;"<<endl;
        stream<<"   rayType type;"<<endl;
        stream<<"};"<<endl;

        //Declare our variables
        stream<<"// Camera Variables"<<endl;
        stream<<"rtDeclareVariable(float3,        eye, , );"<<endl;
        stream<<"// Geometry Variables "<<endl;
        stream<<"rtDeclareVariable(float3, geometric_normal, attribute geometric_normal, ); "<<endl;
        stream<<"rtDeclareVariable(float3, shading_normal,   attribute shading_normal, );"<<endl;
        stream<<"rtDeclareVariable(float3, texcoord, attribute texcoord, );"<<endl;
        stream<<"// Our current ray and payload variables"<<endl;
        stream<<"rtDeclareVariable(optix::Ray, ray,          rtCurrentRay, );"<<endl;
        stream<<"rtDeclareVariable(PerRayData_pathtrace, current_prd, rtPayload, );"<<endl;
        stream<<"\n\n";

        stream<<"//Dynamic Input Variables"<<endl;
        //run through all our connections to find if we have any input variables to declare
        foreach(QGraphicsItem *item, getScene()->items()){
            if (item->type() == QNEConnection::Type)
            {

                //check to see which way round our connection is
                if(((QNEConnection*) item)->port1()->isOutput()){
                    //Convert our input type into a string
                    QString type = portTypeToString(((QNEConnection*) item)->port1()->getVaribleType());
                    //if we have a type and our port belongs to a node that is not a shader node
                    //lets add it to our material variables
                    if((type.size()>0)&&(((QNEConnection*) item)->port1()->block()->type() != OSLShaderBlock::Type)){
                        //node: if multiple shaders have the same variable name then they will clash in the program
                        //to solve this we put the shader name on the start of the variable
                        OSLShaderBlock *block = (OSLShaderBlock*) (((QNEConnection*) item)->port2()->block());
                        stream<<"rtDeclareVariable("<<type<<","<<block->getShaderName().c_str()<<((QNEConnection*) item)->port2()->getName()<<",,);"<<endl;
                    }
                }
                else{
                    //Convert our input type into a string
                    QString type = portTypeToString(((QNEConnection*) item)->port2()->getVaribleType());
                    //if we have a type and our port belongs to a node that is not a shader node
                    //lets add it to our material variables
                    if((type.size()>0)&&(((QNEConnection*) item)->port2()->block()->type() != OSLShaderBlock::Type)){
                        //node: if multiple shaders have the same variable name then they will clash in the program
                        //to solve this we put the shader name on the start of the variable
                        OSLShaderBlock *block = (OSLShaderBlock*) (((QNEConnection*) item)->port1()->block());
                        stream<<"rtDeclareVariable("<<type<<","<<block->getShaderName().c_str()<<((QNEConnection*) item)->port1()->getName()<<",,);"<<endl;
                    }
                }
            }
        }
        stream<<"\n\n";

        //add all the device functions that we need in our material program
        stream<<"//Our OSL device functions"<<endl;
        foreach(QGraphicsItem *item, getScene()->items()){
            if (item->type() == OSLShaderBlock::Type)
            {
                stream<<((OSLShaderBlock*)item)->getDevicefunction().c_str()<<endl;
            }
        }
        stream<<"\n\n";


        //add our main material program funcion
        stream<<"//-------Main Material Program-----------"<<endl;
        stream<<"RT_PROGRAM void "<<m_materialName.c_str()<<"(){"<<endl;


        //Retrieve and print out any variables that we need for our kernal functions
        foreach(QGraphicsItem *item, getScene()->items()){
            if (item->type() == OSLShaderBlock::Type)
            {
                //get the ports of our block
                QVector<QNEPort*> ports= ((OSLShaderBlock*)item)->ports();
                foreach(QNEPort* p, ports){
                    if(p->isOutput()){
                        //if the output ports of our hsader block is connected to
                        //another shader block then we need it as a variable we can
                        //pass data around in our kernals
                        if(p->connections().size()>0){
                            stream<<portTypeToString(p->getVaribleType())<<" ";
                            //note: if 2 shaders have the same variable name we need to
                            //distinguish between them so to solve this we will have the
                            //name of the shader concatinated with the varibale name
                            stream<<((OSLShaderBlock*)item)->getShaderName().c_str()<<p->getName();
                            //lets also set its default value
                            stream<<" = "<<p->getInitParams()<<";"<<endl;
                        }
                    }
                }
            }
        }

        stream<<"\n\n";


        //get our last shader block;
        QNEBlock *lastBlock = getLastBlock();
        //check that we have found a last block
        if(!lastBlock){
            std::cerr<<"Cannot find end block"<<std::endl;
            return;
        }
        //evaluate our blocks so we know the order to call our
        //device functions
        std::vector<QNEBlock*> orderedBlocks;
        evaluateBlock(lastBlock,orderedBlocks);

        //write our code
        for(unsigned int i=0;i<orderedBlocks.size();i++){
            if(orderedBlocks[i]->type() == OSLShaderBlock::Type){
                //note the shader name is always the same as the device function we need to call
                stream<<((OSLShaderBlock*)orderedBlocks[i])->getShaderName().c_str()<<"(";
                //now lets print out our the paramiters we need in the function
                QVector<QNEPort*> ports = ((OSLShaderBlock*)orderedBlocks[i])->ports();
                for(int i=0; i<ports.size(); i++){
                    QNEPort* p = ports[i];

                    //if our port is not a variable then lets skip
                    if(p->getVaribleType() == QNEPort::TypeVoid){
                        continue;
                    }

                    if(p->connections().size()==0){
                        //if there is nothing connected we just stick in our default paramiter
                        stream<<p->getInitParams();
                        if(i!=(ports.size()-1)){
                            stream<<",";
                        }
                    }
                    else if(!p->isOutput()){
                        QVector<QNEConnection*> con = p->connections();
                        if(con.size()!=1){
                            std::cerr<<"Error: Input to shader has multiple input connections"<<std::endl;
                            return;
                        }
                        else{
                            //find which port of the connection is the input and print the variable name
                            if(!con[0]->port1()->isOutput()){
                                OSLShaderBlock* b = (OSLShaderBlock*)con[0]->port1()->block();
                                stream<<b->getShaderName().c_str()<<con[0]->port1()->getName();
                            }
                            else{
                                OSLShaderBlock* b = (OSLShaderBlock*)con[0]->port2()->block();
                                stream<<b->getShaderName().c_str()<<con[0]->port2()->getName();
                            }
                            if(i!=(ports.size()-1)){
                                stream<<",";
                            }
                        }
                    }

                }

                //finish our kernal call
                stream<<");"<<endl;
            }
        }







        //end of our material program
        stream<<"}"<<endl;





    }
    else{
        std::cerr<<"Cannot create material file"<<std::endl;
    }

}
//------------------------------------------------------------------------------------------------------------------------------------
