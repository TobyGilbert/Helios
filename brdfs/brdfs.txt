rtDeclareVariable(unsigned int,  pathtrace_ray_type, , );
rtDeclareVariable(unsigned int,  rr_begin_depth, , );

//----------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------- BRDFS -------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
__device__ optix::float3 diffuse(optix::float3 _normal){
    float z1=rnd(current_prd.seed);
    float z2=rnd(current_prd.seed);
    float3 p;
    cosine_sample_hemisphere(z1, z2, p);
    float3 v1, v2;
    createONB(_normal, v1, v2);

    float3 ray_origin = ray.origin + t_hit * ray.direction;
    float3 ray_direction = v1 * p.x + v2 * p.y + _normal * p.z;
    unsigned int num_lights = lights.size();
    float3 result = make_float3(0.0f);
    float3 ffnormal = faceforward( _normal, -ray.direction, _normal );

    for(int i = 0; i < num_lights; ++i) {
      ParallelogramLight light = lights[i];
      float z1 = rnd(current_prd.seed);
      float z2 = rnd(current_prd.seed);
      float3 light_pos = light.corner + light.v1 * z1 + light.v2 * z2;

      float Ldist = length(light_pos - ray_origin);
      float3 L = normalize(light_pos - ray_origin);
      float nDl = dot( ffnormal, L );
      float LnDl = dot( light.normal, L );
      float A = length(cross(light.v1, light.v2));

      // cast shadow ray
      if ( nDl > 0.0f && LnDl > 0.0f ) {
        PerRayData_pathtrace_shadow shadow_prd;
        shadow_prd.inShadow = false;
        Ray shadow_ray = make_Ray( ray_origin, L, pathtrace_shadow_ray_type, scene_epsilon, Ldist );
        rtTrace(top_object, shadow_ray, shadow_prd);

        if(!shadow_prd.inShadow){
          float weight=nDl * LnDl * A / (M_PIf*Ldist*Ldist);
          result += light.emission * weight;
        }
      }
    }

    current_prd.radiance = result;
    current_prd.countEmitted = false;

    PerRayData_pathtrace prd;
    prd.attenuation = current_prd.attenuation;
    prd.result = current_prd.result + (current_prd.attenuation * current_prd.radiance);
    prd.seed = current_prd.seed;
    prd.depth = current_prd.depth+1;

    Ray reflection_ray = make_Ray( ray_origin, ray_direction, pathtrace_ray_type, scene_epsilon, RT_DEFAULT_MAX );
    rtTrace(top_object, reflection_ray, prd);

    return  optix::make_float3(max(optix::dot(_normal, ray_direction), 0.0f) * float(M_1_PI)) * prd.result;
}
//----------------------------------------------------------------------------------------------------------------------
__device__ optix::float3 phong(optix::float3 _normal, float _exponant){
    float z1 = rnd(current_prd.seed);
    float z2 = rnd(current_prd.seed);
    float sinTheta = sqrt(1 - pow(z1, 2 / (_exponant + 1)));
    float cosTheta= pow(z1, 1 / (_exponant + 1));
    float sinPhi = sin(2*float(M_PI)*z2);
    float cosPhi = cos(2*float(M_PI)*z2);

    float3 ray_origin = ray.origin + t_hit * ray.direction;
    float3 ray_direction = make_float3 (sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
    unsigned int num_lights = lights.size();
    float3 result = make_float3(0.0f);
    float3 ffnormal = faceforward( _normal, -ray.direction, _normal );


    for(int i = 0; i < num_lights; ++i) {
      ParallelogramLight light = lights[i];
      float z1 = rnd(current_prd.seed);
      float z2 = rnd(current_prd.seed);
      float3 light_pos = light.corner + light.v1 * z1 + light.v2 * z2;

      float Ldist = length(light_pos - ray_origin);
      float3 L = normalize(light_pos - ray_origin);
      float nDl = dot( ffnormal, L );
      float LnDl = dot( light.normal, L );
      float A = length(cross(light.v1, light.v2));

      // cast shadow ray
      if ( nDl > 0.0f && LnDl > 0.0f ) {
        PerRayData_pathtrace_shadow shadow_prd;
        shadow_prd.inShadow = false;
        Ray shadow_ray = make_Ray( ray_origin, L, pathtrace_shadow_ray_type, scene_epsilon, Ldist );
        rtTrace(top_object, shadow_ray, shadow_prd);

        if(!shadow_prd.inShadow){
          float weight=nDl * LnDl * A / (M_PIf*Ldist*Ldist);
          result += light.emission * weight;
        }
      }
    }

    current_prd.radiance = result;
    current_prd.countEmitted = false;

    PerRayData_pathtrace prd;
    prd.result = current_prd.result + (current_prd.attenuation * current_prd.radiance);
    prd.seed = current_prd.seed;
    prd.depth = current_prd.depth+1;

    Ray reflection_ray = make_Ray( ray_origin, ray_direction, pathtrace_ray_type, scene_epsilon, RT_DEFAULT_MAX );
    rtTrace(top_object, reflection_ray, prd);

    // n + 2 / 2PI * cos^n (A);
    float3 R = reflect((ray_origin - eye), _normal);
    float A = optix::dot(R, ray_direction);

    if (A > 0){
        return make_float3((( _exponant + 2) / (2 * M_PI * pow(A, _exponant)))) * prd.result;
    }
    return make_float3(0.0);
}
//----------------------------------------------------------------------------------------------------------------------
__device__ optix::float3 reflection(optix::float3 _normal, float _eta){
    float3 ray_origin = ray.origin + t_hit * ray.direction;
    float3 ray_direction = reflect(ray.direction, _normal);
    unsigned int num_lights = lights.size();
    float3 result = make_float3(0.0f);
    float3 ffnormal = faceforward( _normal, -ray.direction, _normal );

    for(int i = 0; i < num_lights; ++i) {
      ParallelogramLight light = lights[i];
      float z1 = rnd(current_prd.seed);
      float z2 = rnd(current_prd.seed);
      float3 light_pos = light.corner + light.v1 * z1 + light.v2 * z2;

      float Ldist = length(light_pos - ray_origin);
      float3 L = normalize(light_pos - ray_origin);
      float nDl = dot( ffnormal, L );
      float LnDl = dot( light.normal, L );
      float A = length(cross(light.v1, light.v2));

      // cast shadow ray
      if ( nDl > 0.0f && LnDl > 0.0f ) {
        PerRayData_pathtrace_shadow shadow_prd;
        shadow_prd.inShadow = false;
        Ray shadow_ray = make_Ray( ray_origin, L, pathtrace_shadow_ray_type, scene_epsilon, Ldist );
        rtTrace(top_object, shadow_ray, shadow_prd);

        if(!shadow_prd.inShadow){
          float weight=nDl * LnDl * A / (M_PIf*Ldist*Ldist);
          result += light.emission * weight;
        }
      }
    }

    current_prd.radiance = result;
    current_prd.countEmitted = false;

    PerRayData_pathtrace prd;
    prd.attenuation = current_prd.attenuation;
    prd.result = current_prd.result + (current_prd.attenuation * current_prd.radiance);
    prd.seed = current_prd.seed;
    prd.depth = current_prd.depth+1;

    Ray reflection_ray = make_Ray( ray_origin, ray_direction, pathtrace_ray_type, scene_epsilon, RT_DEFAULT_MAX );
    rtTrace(top_object, reflection_ray, prd);

    return prd.result;
}
//----------------------------------------------------------------------------------------------------------------------
__device__ optix::float3 refraction(optix::float3 _normal, float _eta){
    float3 ray_origin = ray.origin + t_hit * ray.direction;
    float3 ray_direction = ray.direction;

    refract(ray_direction, ray_direction, _normal, _eta);

    float3 ffnormal = faceforward( _normal, -ray.direction, _normal );

    // Compute radiance
    // Compute direct light...
    // Or shoot one...
    unsigned int num_lights = lights.size();
    float3 result = make_float3(0.0f);

    for(int i = 0; i < num_lights; ++i) {
      ParallelogramLight light = lights[i];
      float z1 = rnd(current_prd.seed);
      float z2 = rnd(current_prd.seed);
      float3 light_pos = light.corner + light.v1 * z1 + light.v2 * z2;

      float Ldist = length(light_pos - ray_origin);
      float3 L = normalize(light_pos - ray_origin);
      float nDl = dot( ffnormal, L );
      float LnDl = dot( light.normal, L );
      float A = length(cross(light.v1, light.v2));

      // cast shadow ray
      if ( nDl > 0.0f && LnDl > 0.0f ) {
        PerRayData_pathtrace_shadow shadow_prd;
        shadow_prd.inShadow = false;
        Ray shadow_ray = make_Ray( ray_origin, L, pathtrace_shadow_ray_type, scene_epsilon, Ldist );
        rtTrace(top_object, shadow_ray, shadow_prd);

        if(!shadow_prd.inShadow){
          float weight=nDl * LnDl * A / (M_PIf*Ldist*Ldist);
          result += light.emission * weight;
        }
      }
    }

    current_prd.radiance = result;
    current_prd.countEmitted = false;

    PerRayData_pathtrace prd;
    prd.attenuation = current_prd.attenuation;
    prd.radiance = make_float3(0.0);
    prd.result = current_prd.result + (current_prd.attenuation * current_prd.radiance);
    prd.seed = current_prd.seed;
    prd.depth = current_prd.depth+1;

    Ray refraction_ray = make_Ray( ray_origin, ray_direction, pathtrace_ray_type, scene_epsilon, RT_DEFAULT_MAX );
    rtTrace(top_object, refraction_ray, prd);

    return prd.result;
}
//----------------------------------------------------------------------------------------------------------------------
__device__ optix::float3 oren_nayar(float3 _normal, float _sigma){
    float z1=rnd(current_prd.seed);
    float z2=rnd(current_prd.seed);
    float3 p;
    cosine_sample_hemisphere(z1, z2, p);
    float3 v1, v2;
    createONB(_normal, v1, v2);

    float3 ray_direction = v1 * p.x + v2 * p.y + _normal * p.z;
    float3 ray_origin =  ray.origin + t_hit * ray.direction;
    unsigned int num_lights = lights.size();
    float3 result = make_float3(0.0f);
    float3 ffnormal = faceforward( _normal, -ray.direction, _normal );


    for(int i = 0; i < num_lights; ++i) {
      ParallelogramLight light = lights[i];
      float z1 = rnd(current_prd.seed);
      float z2 = rnd(current_prd.seed);
      float3 light_pos = light.corner + light.v1 * z1 + light.v2 * z2;

      float Ldist = length(light_pos - ray_origin);
      float3 L = normalize(light_pos - ray_origin);
      float nDl = dot( ffnormal, L );
      float LnDl = dot( light.normal, L );
      float A = length(cross(light.v1, light.v2));

      // cast shadow ray
      if ( nDl > 0.0f && LnDl > 0.0f ) {
        PerRayData_pathtrace_shadow shadow_prd;
        shadow_prd.inShadow = false;
        Ray shadow_ray = make_Ray( ray_origin, L, pathtrace_shadow_ray_type, scene_epsilon, Ldist );
        rtTrace(top_object, shadow_ray, shadow_prd);

        if(!shadow_prd.inShadow){
          float weight=nDl * LnDl * A / (M_PIf*Ldist*Ldist);
          result += light.emission * weight;
        }
      }
    }

    current_prd.radiance = result;
    current_prd.countEmitted = false;

    PerRayData_pathtrace prd;
    prd.result = current_prd.result + (current_prd.radiance * current_prd.attenuation);
    prd.seed = current_prd.seed;
    prd.depth = current_prd.depth+1;

    Ray refraction_ray = make_Ray( ray_origin, ray_direction, pathtrace_ray_type, scene_epsilon, RT_DEFAULT_MAX );
    rtTrace(top_object, refraction_ray, prd);

    float3 L = ray_direction;
    float3 V = (ray_origin - eye);

    float A = 1 / (M_PI + ((M_PI / 2) - (2/3)) * _sigma );
    float B = _sigma / (M_PI + ( (M_PI /2) - (2/3)) * _sigma);
    float s = optix::dot(L, V) - optix::dot(_normal, L) * optix::dot(_normal, V);
    float t;
    if ( s <= 0.0){
        t = 1.0;
    }
    else{
        t = max(optix::dot(_normal, L), optix::dot(_normal, V));
    }

    return make_float3(0.8 * optix::dot(_normal, L) * (A + B * (s / t))) * prd.result;
}
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
__device__ int OSLraytype(char* _char){
  return 0;
}
//----------------------------------------------------------------------------------------------------------------------
__device__ int OSLbackfacing(ShaderGlobals sg){
    if (optix::dot(-ray.direction, sg.N) > 0.0){
      return 0;
    }
    else{
      return 1;
    }
}
//----------------------------------------------------------------------------------------------------------------------
__device__ optix::float3 OSLTexture(rtTextureSampler<float4, 2>  _filename, float _s, float _t){
    return make_float3(tex2D(_filename, _s, _t));
}
//----------------------------------------------------------------------------
